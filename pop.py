# -*- coding: utf-8 -*-
"""
Special Pythagorean triplet
Problem 9
A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,

a2 + b2 = c2
For example, 32 + 42 = 9 + 16 = 25 = 52.

There exists exactly one Pythagorean triplet for which a + b + c = 1000.
Find the product abc.


Answer:
31875000
Completed on Tue, 22 Jan 2013, 21:52

----
Euclid's formula[1] is a fundamental formula for generating Pythagorean triples given an arbitrary pair of positive integers m and n with m > n. The formula states that the integers

form a Pythagorean triple. The triple generated by Euclid's formula is primitive if and only if m and n are coprime and m − n is odd. If both m and n are odd, then a, b, and c will be even, and so the triple will not be primitive; however, dividing a, b, and c by 2 will yield a primitive triple if m and n are coprime.[2]
Every primitive triple (possibly after exchanging a and b) arises from a unique pair of coprime numbers m, n, one of which is even. It follows that there are infinitely many primitive Pythagorean triples. This relationship of a and b to m and n from Euclid's formula is referenced throughout the rest of this article.
Despite generating all primitive triples, Euclid's formula does not produce all triples. This can be remedied by inserting an additional parameter k to the formula. The following will generate all Pythagorean triples uniquely:

where m, n, and k are positive integers with m > n, m − n odd, and with m and n coprime.
"""
count=0
import fractions
import time
#T=set()
ras=time.time()
nset=[r for r in range(1,10000)]
def mset(n):
    begin=n+1
 #   mset=[r for r in range(begin,10000) if fractions.gcd(r,n)==1]
    frog=set()
    v=2
    k=n
    while k>=v:
        if k%v==0:
            frog.add(v)
            k=k/v
        v+=1
    mset=[r for r in range(begin,10001)]
    for i in frog:
         
        
        camp=[r for r in mset if r%i!=0]
        mset=camp[:]
    return mset
 
 
 

for n in nset:
    j=mset(n)
    if n==2:
        print"one done"
    if n%1000==0:
        print n
    for m in j:
     
     
     if (m-n)%2==1:
            a=(m**2-n**2)
            b=2*m*n
            c=(m**2+n**2)
     
      
            if (a+b+c)<100000000:
                if c%abs(a-b)==0:
 #             T.add(tuple([a,b,c]))
                   count+=100000000/(a+b+c)
            else:
                break
            
print count            
print time.time()-ras 
